// ========================================
// 测试4：错误检测 - 各种非法的初始化列表用法
// ========================================

struct Point {
    int x;
    int y;
};

// ========== 以下是正确的用法（作为对照） ==========

int correct_scalar = {42};              // 正确：标量单元素
int correct_arr[3] = {1, 2, 3};         // 正确：数组完整初始化
int correct_arr2[5] = {1, 2};           // 正确：数组部分初始化
struct Point correct_p = {10, 20};      // 正确：结构体完整初始化
struct Point correct_p2 = {5};          // 正确：结构体部分初始化

// ========== 以下是错误的用法（注释掉以便通过编译） ==========

// 错误1：标量类型使用多元素初始化列表
// int error_scalar = {1, 2, 3};
// 预期错误：标量类型的初始化列表只能包含一个元素

// 错误2：全局数组使用非常量表达式
// int x = 10;
// int error_arr[3] = {x, x + 1, x + 2};
// 预期错误：全局数组初始化列表的第 1 个元素必须是编译时常量表达式

// 错误3：数组初始化列表元素过多
// int error_arr_overflow[3] = {1, 2, 3, 4, 5};
// 预期错误：数组初始化列表元素过多：数组大小为 3，但提供了 5 个元素

// 错误4：结构体初始化列表元素过多
// struct Point error_p_overflow = {1, 2, 3};
// 预期错误：结构体初始化列表元素过多：结构体有 2 个成员，但提供了 3 个元素

// 错误5：全局结构体使用非常量表达式
// int y = 20;
// struct Point error_p_non_const = {10, y};
// 预期错误：全局结构体初始化列表的第 2 个元素必须是编译时常量表达式

int main() {
    // 局部变量可以使用运行时表达式（这是正确的）
    int z = 5;
    int local_arr[3] = {z, z + 1, z + 2};
    struct Point local_p = {z, z * 2};

    return 0;
}
